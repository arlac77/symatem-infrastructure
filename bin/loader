#!/usr/bin/env node

/* jslint node: true, esnext: true */

'use strict';

const symatem = require('symatem'),
  fs = require('fs'),
  zonefile = require('dns-zonefile'),
  commander = require('commander');

commander
//.version(module.exports.version)
//.description('run cluster node')
  .option('--store <file>', 'symatem store')
  .option('--hrl <file>', 'hrl source')
  .parse(process.argv);


function createSymbolCache(connection) {
  const symbolCache = {};
  const ongoing = {};

  return function (symbols) {
    return Promise.all(symbols.map(symbol => {
      if (symbolCache[symbol]) {
        //console.log(`already found: ${symbol}`);
        return Promise.resolve(symbolCache[symbol]);
      }
      if (ongoing[symbol]) {
        //console.log(`already requested: ${symbol}`);
        return ongoing;
      }

      const p = connection.decodeSymbol(symbol).then(decoded => {
        //console.log(`add ${symbol} -> ${decoded.name}`);
        symbolCache[symbol] = decoded;
        delete ongoing[symbol];
        return decoded;
      });
      ongoing[symbol] = p;
      return p;
    }));
  };
}

let symbolDecoder;

symatem.open({
    store: commander.store
  }).then(connection => {
    symbolDecoder = createSymbolCache(connection);
    return connection;
  })
  .then(connection => connection.upload(fs.readFileSync(commander.hrl))
    .then(result => connection.upload('networkInterface')
      .then(result => connection.query(false, symatem.queryMask.VMV, 0, result[0], 0)
        .then(result => symbolDecoder(result))
        .then(
          decoded => {
            connection.upload('network')
              .then(result => connection.query(false, symatem.queryMask.VIM, 0, result[0], 0))
              .then(result => symbolDecoder(result))
              .then(symbols => {
                console.log(symbols);
              }).catch(e => console.error(e));

            const zone = {
              '$origin': '0.168.192.IN-ADDR.ARPA.',
              '$ttl': 3600,
              soa: {
                mname: 'NS1.NAMESERVER.NET.',
                rname: 'HOSTMASTER.MYDOMAIN.COM.',
                serial: '{time}',
                refresh: 3600,
                retry: 600,
                expire: 604800,
                minimum: 86400
              },
              ns: [],
              a: [],
              aaaa: [],
              ptr: []
            };

            for (let i = 0; i < decoded.length; i += 2) {
              const a = decoded[i + 0];
              const b = decoded[i + 1];

              //delete a.BlobType;
              //delete a.networkInterface;
              //delete b.BlobType;

              if (b.ipv4Address !== undefined) {
                zone.a.push({
                  ip: b.ipv4Address,
                  name: a.name
                });
              }
              if (b.ipv6Address !== undefined) {
                zone.aaaa.push({
                  ip: b.ipv6Address,
                  name: a.name
                });
              }

              if (a.product) {
                zone.ptr.push({
                  name: zone.ptr.length + 1,
                  host: a.name
                });
              }
              //console.log(`${JSON.stringify(a)} <> ${JSON.stringify(b)}`);
            }

            console.log(zonefile.generate(zone));
            connection.close();
          }
        )
      )
    )
    .catch(result => console.error(result)));
