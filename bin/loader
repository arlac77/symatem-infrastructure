#!/usr/bin/env node

/* jslint node: true, esnext: true */

'use strict';

const symatem = require('symatem'),
  path = require('path'),
  fs = require('fs'),
  zonefile = require('dns-zonefile'),
  commander = require('commander'),
  plist = require('plist');



commander
//.version(module.exports.version)
//.description('run cluster node')
  .option('--store <file>', 'symatem store')
  .option('--hrl <file>', 'hrl source')
  .option('--out <dir>', 'output directory')
  .parse(process.argv);

const out = commander.out || '/tmp';

symatem.open({
  store: commander.store
}).then(connection => connection.upload(fs.readFileSync(commander.hrl))
  .then(result => connection.upload('networkInterface')
    .then(result => connection.query(false, symatem.queryMask.VMV, 0, result[0], 0)
      .then(symbols => symbols.map(symbol => connection.decodeSymbolWithCache(symbol)))
      .then(dps => Promise.all(dps))
      .then(
        decoded => {
          const promises = [];

          promises.push(connection.upload('network')
            .then(result => connection.query(false, symatem.queryMask.VIM, 0, result[0], 0))
            .then(symbols => symbols.map(symbol => connection.decodeSymbolWithCache(symbol)))
            .then(dps => Promise.all(dps))
            .then(symbols => {
              console.log(symbols);
            }));

          const zone = {
            '$origin': '0.168.192.IN-ADDR.ARPA.',
            '$ttl': 3600,
            soa: {
              mname: 'NS1.NAMESERVER.NET.',
              rname: 'HOSTMASTER.MYDOMAIN.COM.',
              serial: '{time}',
              refresh: 3600,
              retry: 600,
              expire: 604800,
              minimum: 86400
            },
            ns: [],
            a: [],
            aaaa: [],
            ptr: []
          };

          for (let i = 0; i < decoded.length; i += 2) {
            const a = decoded[i + 0];
            const b = decoded[i + 1];

            if (b.ipv4Address !== undefined) {
              zone.a.push({
                ip: b.ipv4Address,
                name: a.name
              });
            }
            if (b.ipv6Address !== undefined) {
              zone.aaaa.push({
                ip: b.ipv6Address,
                name: a.name
              });
            }

            if (a.product) {
              zone.ptr.push({
                name: zone.ptr.length + 1,
                host: a.name
              });
            }

            if (a.manufacturer === undefined) {
              //console.log(`${JSON.stringify(a)} <> ${JSON.stringify(b)}`);

              const name = a.name;

              const json = {
                name: [name],
                en_address: [],
                ip_address: [],
                ipaddressandenetaddress: []
              };

              if (b.macAddress) {
                json.en_address.push(b.macAddress);
              }
              if (b.ipv4Address) {
                json.ip_address.push(b.ipv4Address);

                if (b.macAddress) {
                  json.ipaddressandenetaddress.push(`${b.ipv4Address}/${b.macAddress}`);
                }
              }

              promises.push(writeFile(path.join(out, `${name}.plist`), plist.build(json)));
            }
          }

          promises.push(writeFile(path.join(out, 'a.zone'), zonefile.generate(zone)));

          Promise.all(promises)
            .then(() => console.log('done'))
            .catch(e => console.error(e));

          connection.close();
        }
      )
    )
  )
  .catch(result => console.error(result)));


function writeFile(name, encoding) {
  return new Promise((fullfill, reject) => {
    fs.writeFile(name, encoding, error => {
      if (error) {
        reject(error);
      } else {
        fullfill();
      }
    });
  });
}
