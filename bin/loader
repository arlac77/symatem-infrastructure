#!/usr/bin/env node

/* jslint node: true, esnext: true */

'use strict';

const symatem = require('symatem'),
  path = require('path'),
  fs = require('fs'),
  zonefile = require('dns-zonefile'),
  commander = require('commander'),
  plist = require('plist');



commander
//.version(module.exports.version)
//.description('run cluster node')
  .option('--store <file>', 'symatem store')
  .option('--hrl <file>', 'hrl source')
  .option('--out <dir>', 'output directory')
  .parse(process.argv);

const out = commander.out || '/tmp';

function createSymbolCache(connection) {
  const symbolCache = {};
  const ongoing = {};

  return function (symbols) {
    return Promise.all(symbols.map(symbol => {
      if (symbolCache[symbol]) {
        //console.log(`already found: ${symbol}`);
        return Promise.resolve(symbolCache[symbol]);
      }
      if (ongoing[symbol]) {
        //console.log(`already requested: ${symbol}`);
        return ongoing;
      }

      const p = connection.decodeSymbol(symbol).then(decoded => {
        //console.log(`add ${symbol} -> ${decoded.name}`);
        symbolCache[symbol] = decoded;
        delete ongoing[symbol];
        return decoded;
      });
      ongoing[symbol] = p;
      return p;
    }));
  };
}

let symbolDecoder;

symatem.open({
    store: commander.store
  }).then(connection => {
    symbolDecoder = createSymbolCache(connection);
    return connection;
  })
  .then(connection => connection.upload(fs.readFileSync(commander.hrl))
    .then(result => connection.upload('networkInterface')
      .then(result => connection.query(false, symatem.queryMask.VMV, 0, result[0], 0)
        .then(result => symbolDecoder(result))
        .then(
          decoded => {
            connection.upload('network')
              .then(result => connection.query(false, symatem.queryMask.VIM, 0, result[0], 0))
              .then(result => symbolDecoder(result))
              .then(symbols => {
                console.log(symbols);
              }).catch(e => console.error(e));

            const promises = [];

            const zone = {
              '$origin': '0.168.192.IN-ADDR.ARPA.',
              '$ttl': 3600,
              soa: {
                mname: 'NS1.NAMESERVER.NET.',
                rname: 'HOSTMASTER.MYDOMAIN.COM.',
                serial: '{time}',
                refresh: 3600,
                retry: 600,
                expire: 604800,
                minimum: 86400
              },
              ns: [],
              a: [],
              aaaa: [],
              ptr: []
            };

            for (let i = 0; i < decoded.length; i += 2) {
              const a = decoded[i + 0];
              const b = decoded[i + 1];

              //delete a.BlobType;
              //delete a.networkInterface;
              //delete b.BlobType;

              if (b.ipv4Address !== undefined) {
                zone.a.push({
                  ip: b.ipv4Address,
                  name: a.name
                });
              }
              if (b.ipv6Address !== undefined) {
                zone.aaaa.push({
                  ip: b.ipv6Address,
                  name: a.name
                });
              }

              if (a.product) {
                zone.ptr.push({
                  name: zone.ptr.length + 1,
                  host: a.name
                });
              }

              //console.log(`${JSON.stringify(a)} <> ${JSON.stringify(b)}`);
              //
              const name = a.name;

              const json = {
                name: [name],
                en_address: [],
                ip_address: [],
                ipaddressandenetaddress: []
              };

              if (b.macAddress) {
                json.en_address.push(b.macAddress);
              }
              if (b.ipv4Address) {
                json.ip_address.push(b.ipv4Address);

                if (b.macAddress) {
                  json.ipaddressandenetaddress.push(`${b.ipv4Address}/${b.macAddress}`);
                }
              }

              promises.push(writeFile(path.join(out, `${name}.plist`), plist.build(json)));
            }

            promises.push(writeFile(path.join(out, 'a.zone'), zonefile.generate(zone)));

            Promise.all(promises).then(() => {
              console.log('done');
            });

            connection.close();
          }
        )
      )
    )
    .catch(result => console.error(result)));


function writeFile(name, encoding) {
  return new Promise((fullfill, reject) => {
    fs.writeFile(name, encoding, error => {
      if (error) {
        reject(error);
      } else {
        fullfill();
      }
    });
  });
}
